<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html><body style="margin-top:5px"><h3>Machine language</h3>


    <div id="question1" class="question">
    <p/><hr/><p/><u>Problem 1.</u>
    
Hand-compile the following C fragments into Beta assembly language.
You can assume that the necessary storage allocation for each variable
or array has been done and that a UASM label has been defined that
indicates the first storage location for that variable or array.
All of the variables are stored in main memory (in the first 32k
bytes of main memory so that they can be addressed by a 16-bit literal).
You can also assume that all variables and arrays are C integers,
i.e., 32-bit values.


    <div id="question1A" class="question">
    <ol type="A" start="1"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Explain what Beta assembly language instruction(s) are needed
to load the value of a variable that has been allocated in the first
32k bytes of main memory (i.e., at an address less than 0x8000).
How would your answer change if the variable was located at address
outside this range (e.g., at address 0x12468).


</li></ol></div>

    <div id="question1B" class="question">
    <ol type="A" start="2"><li>
    
<img src="star.gif" alt="Discussed in section"/>
a = b + 3*c;


</li></ol></div>

    <div id="question1C" class="question">
    <ol type="A" start="3"><li>
    
<img src="star.gif" alt="Discussed in section"/>
if (a > b) c = 17;


</li></ol></div>

    <div id="question1D" class="question">
    <ol type="A" start="4"><li>
    
if (sxt_short) { b = (b &lt;&lt; 16) &gt;&gt; 16; }


</li></ol></div>

    <div id="question1E" class="question">
    <ol type="A" start="5"><li>
    
cjt->salary += 3752;<br/>
Assume that the salary component of the structure pointed to by
cjt has a byte offset of 8 from the beginning of the structure.


</li></ol></div>

    <div id="question1F" class="question">
    <ol type="A" start="6"><li>
    
a[i] = a[i-1];


</li></ol></div>

    <div id="question1G" class="question">
    <ol type="A" start="7"><li>
    
<img src="star.gif" alt="Discussed in section"/>
sum = 0;<br/>
for (i = 0; i &lt; 10; i = i+1) sum += i;


</li></ol></div>
</div>

    <div id="question2" class="question">
    <p/><hr/><p/><u>Problem 2.</u>
    
In block structured languages such as C or Java, the scope of a
variable declared locally within a block extends only over that block,
i.e., the value of the local variable cannot be accessed outside the
block.  Conceptually, storage is allocated for the variable when the
block is entered and deallocated when the block is exited.  In many
cases, this means the compiler if free to use a register to hold
the value of the local variable instead of a memory location.

<p/>Consider the following C fragment:

<pre>int sum = 0;
{ int i;
  for (i = 0; i &lt; 10; i = i+1) sum += i;
}
</pre>


    <div id="question2A" class="question">
    <ol type="A" start="1"><li>
    
Hand-compile this loop into assembly language, using registers
to hold the values of the local variables "i" and "sum".


</li></ol></div>

    <div id="question2B" class="question">
    <ol type="A" start="2"><li>
    
Define a <i>memory access</i> as any access to memory, i.e.,
instruction fetch, data read (LD), or data write (ST).  Compare
the number of total number of memory accesses generated by executing the 
optimized loop with the total number of memory access
for the unoptimized loop (part G of the preceding problem).


</li></ol></div>

    <div id="question2C" class="question">
    <ol type="A" start="3"><li>
    
Some optimizing compilers "unroll" small loops to amortize the
overhead of each loop iteration over more instructions in the body
of the loop.  For example, one unrolling of the loop above would be
equivalent to rewriting the program as

<pre>int sum = 0;
{ int i;
  for (i = 0; i &lt; 10; i = i+2) { sum += i; sum += i+1; }
}
</pre>

<p/>Hand-compile this loop into Beta assembly language and compare the
total number of memory accesses generated when it executes to the
total number of memory accesses from part (1).


</li></ol></div>
</div>

    <div id="question3" class="question">
    <p/><hr/><p/><u>Problem 3.</u>
    


    <div id="question3A" class="question">
    <ol type="A" start="1"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Hand-assemble the following Beta assembly language program:

<pre>
        I = 0x5678
        B = 0x1234

        LD(I,R0)
        SHLC(R0,2,R0)
        LD(R0,B,R1)
        MULC(R1,17,R1)
        ST(R1,B,R0)
</pre>


</li></ol></div>

    <div id="question3B" class="question">
    <ol type="A" start="2"><li>
    
What C statement might have been compiled into the code fragment
above?


</li></ol></div>
</div>

    <div id="question4" class="question">
    <p/><hr/><p/><u>Problem 4.</u>
    
Hand-assemble the following Beta branch instructions into their
binary representation:


    <div id="question4A" class="question">
    <ol type="A" start="1"><li>
    
foo: BR(foo)   [recall that BR(label) = BEQ(R31,label,R31)]


</li></ol></div>

    <div id="question4B" class="question">
    <ol type="A" start="2"><li>
    
BR(bar)<br/>bar:


</li></ol></div>

    <div id="question4C" class="question">
    <ol type="A" start="3"><li>
    
<img src="star.gif" alt="Discussed in section"/>
foo = 0x100<br/>. = 0x1000<br/>BF(R17,foo,R31)


</li></ol></div>

    <div id="question4D" class="question">
    <ol type="A" start="4"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Explain why PC-relative branch addressing is a good choice
for computers like the Beta that can encode only a "small" constant
in each instruction.


</li></ol></div>

    <div id="question4E" class="question">
    <ol type="A" start="5"><li>
    
Suppose a different computer could encode
an arbitrary 32-bit constant in an instruction (using, e.g., a
variable-length instruction encoding).  Would PC-relative addressing
still make sense?  Why?


</li></ol></div>
</div>

    <div id="question5" class="question">
    <p/><hr/><p/><u>Problem 5.</u>
    


    <div id="question5A" class="question">
    <ol type="A" start="1"><li>
    
True or false: The Beta SUBC opcode could be eliminated since every
SUBC instruction can be replaced an equivalent ADDC instruction.


</li></ol></div>

    <div id="question5B" class="question">
    <ol type="A" start="2"><li>
    
What is the binary representation for the Beta instruction
SUBC(R17,12,R22)?


</li></ol></div>

    <div id="question5C" class="question">
    <ol type="A" start="3"><li>
    
A certain TA wants to know what would happen if the Beta as
implemented in the lab executed 0xEDEDEDED as an instruction.  What
does happen?


</li></ol></div>

    <div id="question5D" class="question">
    <ol type="A" start="4"><li>
    
Suppose that the Beta instruction BR(error) were assembled into
memory location 0x87654.  Assuming that the instruction works as
intended (i.e., when executed, control is transferred to the first
instruction in the error routine), which of the following is the best
statement about the possible values for the symbol "error"?

<ol type="A">
<li>it depends on the first instruction in the error routine.</li>
<li>it can have any 32-bit value</li>
<li>it can have any 32-bit value that is a multiple of 4</li>
<li>it is a multiple of 4 in the range 0x7F658 to 0x8F654 inclusive.</li>
<li>it is a multiple of 4 in the range 0x67658 to 0xA7654 inclusive.</li>
<li>none of the above</li>
</ol>


</li></ol></div>
</div>

    <div id="question6" class="question">
    <p/><hr/><p/><u>Problem 6.</u>
    
The Meta is a processor similar to the Beta, except that the data
paths have been modified to accommodate the addition of a new Subtract
One and Branch instruction:

<pre>  Usage: SOB(Ra,label,Rc)
  Operation:
    literal = ((OFFSET(label) - OFFSET(current inst))/4) - 1
    PC = PC + 4
    EA = PC + 4*SEXT(literal)
    Reg[Rc] = Reg[Ra] - 1
    if (Reg[Ra]- 1) != 0 then PC = EA
</pre>

<p/>As with branches in the Beta, the binary encoding of the SOB
instruction places the low-order 16 bits of the "literal" value in the
low-order 16 bits of the instruction.  The designers of the Meta
implementation have used the Meta's ALU to perform the subtraction.


    <div id="question6A" class="question">
    <ol type="A" start="1"><li>
    
Suppose R1 contains the value 1.  How will executing SOB(R1,label,R31)
change register R1 and the PC?


</li></ol></div>

    <div id="question6B" class="question">
    <ol type="A" start="2"><li>
    
Consider the following instruction sequence:

<pre>loop: ADD(R1,R2,R3)
      SOB(R4,loop,R4)
</pre>

<p/>Assuming the ADD instruction is placed in location 0x108 of memory,
what are the contents of the low-order 16 bits of the SOB instruction?


</li></ol></div>

    <div id="question6C" class="question">
    <ol type="A" start="3"><li>
    
A schematic for the adder circuitry in the ALU of the Meta is shown below:

<p/><img src="machinelang01.gif"/>
 
<p/>What would be the correct values for OP[2:0] in order to perform a
subtract (i.e., SUM = A - B)?


</li></ol></div>

    <div id="question6D" class="question">
    <ol type="A" start="4"><li>
    
What would be the correct values for OP[2:0] in order to
perform the decrement needed for the SOB instruction (i.e., SUM = A -
1)?


</li></ol></div>

    <div id="question6E" class="question">
    <ol type="A" start="5"><li>
    
Is it possible to use the logic above to do an increment (i.e., SUM = A+1)?


</li></ol></div>
</div>

    <div id="question7" class="question">
    <p/><hr/><p/><u>Problem 7.</u>
    
A local junk yard offers older CPUs with non-Beta architectures
that require several clocks to execute each instruction.  Here are the
specifications:

<p/><table border="1" cellspacing="2">
<tr><th>Model</th><th>Clock Rate</th><th>Avg. clocks/Inst.</th></tr>
<tr><td>x</td><td>40 Mhz</td><td>2.0</td></tr>
<tr><td>y</td><td>100 Mhz</td><td>10.0</td></tr>
<tr><td>z</td><td>60 Mhz</td><td>3.0</td></tr>
</table>

<p/>You are going to choose the machine which will execute your
benchmark program the fastest, so you compiled and ran the benchmark
on the three machines and counted the total instructions executed:

<ul>
x: 3,600,000 instructions executed<br/>
y: 1,900,000 instructions executed<br/>
z: 4,200,000 instructions executed
</ul>


    <div id="question7A" class="question">
    <ol type="A" start="1"><li>
    
Based on the above data which machine would you choose?


</li></ol></div>
</div>

    <div id="question8" class="question">
    <p/><hr/><p/><u>Problem 8.</u>
    
Kerry DeWay is proposing to add a "Load Constant" instruction
LDC(const,Rx) to the Beta instruction set.  LDC loads the 32-bit
constant const in register Rx.  She can't convince the hardware team
to implement LDC directly and consequently plans to define it as a
macro.  She is considering the following alternative implementations:

<pre>
[1] .macro LDC(const,Rx) {
       LD(.+8,Rx)
       BR(.+8)
       LONG(const)
    }

[2] .macro LDC(const,Rx) {
       PUSH(R17)
       BR(.+8,R17)
       LONG(const)
       LD(R17,0,Rx)
       POP(R17)
    }

[3] .macro LDC(const,Rx) {
       ADDC(R31,const >> 16,Rx)
       SHLC(Rx,16,Rx)
       ADDC(Rx,const &amp; 0xFFFF,Rx)
    }
</pre>

Kerry tries each definition on a few test cases and convinces herself
each works fine.  The Quality Assurance team isn't so sure and
complains that Kerry's LDC implementations don't all work for every
choice of register (Rx), every choice of constant (const), and every
choice of code location.


    <div id="question8A" class="question">
    <ol type="A" start="1"><li>
    
Evaluate each approach and decide whether it works under all
circumstances or if it fails, indicate that it misbehaves for certain
choices of Rx, const or code location.


</li></ol></div>
</div>

    <div id="question9" class="question">
    <p/><hr/><p/><u>Problem 9.</u>
    
Which of the following Beta instruction sequences
might have resulted from compiling the following C statement?

<pre>int x[20], y;
y = x[1] + 4;
</pre>


    <div id="question9A" class="question">
    <ol type="A" start="1"><li>
    
LD (R31, x + 1, R0)<br/>
ADDC (R0, 4, R0)<br/>
ST (R0, y, R31)


</li></ol></div>

    <div id="question9B" class="question">
    <ol type="A" start="2"><li>
    
CMOVE (4, R0)<br/>
ADDC (R0, x + 4, R0)<br/>
ST (R0, y, R31)


</li></ol></div>

    <div id="question9C" class="question">
    <ol type="A" start="3"><li>
    
LD (R31, x + 4, R0)<br/>
ST (R0, y + 4, R31)


</li></ol></div>

    <div id="question9D" class="question">
    <ol type="A" start="4"><li>
    
<img src="star.gif" alt="Discussed in section"/>
CMOVE (4, R0)<br/>
LD (R0, x, R1)<br/>
ST (R1, y, R0)


</li></ol></div>

    <div id="question9E" class="question">
    <ol type="A" start="5"><li>
    
<img src="star.gif" alt="Discussed in section"/>
LD (R31, x + 4, R0)<br/>
ADDC (R0, 4, R0)<br/>
ST (R0, y, R31)


</li></ol></div>

    <div id="question9F" class="question">
    <ol type="A" start="6"><li>
    
<img src="star.gif" alt="Discussed in section"/>
ADDC (R31, x  + 1, R0)<br/>
ADDC (R0, 4, R0)<br/>
ST (R0, y, R31)


</li></ol></div>
</div>

    <div id="question10" class="question">
    <p/><hr/><p/><u>Problem 10.</u>
    
An unnamed associate of yours has broken into the computer (a Beta of
course!) that 6.004 uses for course administration.  He has managed to
grab the contents of the memory locations he believes holds the Beta
code responsible for checking access passwords and would like you to
help discover how the password code works.  The memory contents are
shown in the table below:

<pre>Address	Contents (in hexadecimal)
0x100	0xC05F0008
0x104	0xC03F0000
0x108	0xE060000F
0x10C	0xF0210004
0x110	0xA4230800
0x114	0xF4000004
0x118	0xC4420001
0x11C	0x77E20002
0x120	0x77FFFFF9
0x124	0xA4230800
0x128	0x605F0124
0x12C	0x90211000
</pre>


    <div id="question10A" class="question">
    <ol type="A" start="1"><li>
    
Reconstruct the Beta assembly code that corresponds to the binary
instruction encoding shown above.  If the code sequence contains
branches, be sure to indicate the destination of each branch.


</li></ol></div>

    <div id="question10B" class="question">
    <ol type="A" start="2"><li>
    
Further investigation reveals that the password is just a 32-bit
integer which is in R0 when the code above is executed and that the
system will grant access if R1 = 1 after the code has been executed.
What "passnumber" will gain entry to the system?


</li></ol></div>
</div>
</body></html>
