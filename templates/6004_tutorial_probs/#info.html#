<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html><head><script language="JavaScript1.2" src="tutprobs.js"></script></head><body style="margin-top:5px">
	<noscript><table width=100%% border="1" cellpadding="8" bgcolor="yellow"><tr><td>
        You need to have Javascript enabled to view this page
        properly.  If your browser does not support Javascript
        or you have chosen not to enable it, please return to
        the previous page and use the appropriate link to view
        non-script versions of this tutorial page.
        </td></tr></table></noscript><h3>Basics of information</h3>
        <a href="\#" onClick="showall(); return false"><img border="0" src="showall.gif"/></a>
        &nbsp;
        <a href="\#" onClick="hideall(); return false"><img border="0" src="hideall.gif"/></a>
        <p/><img src="star.gif" alt="Discussed in section"/>
        indicates problems that have been selected for discussion
        in section, time permitting.
        


    <div id="question1" class="question">
    <p/><hr/><p/><u>Problem 1.</u>
    
<b>Measuring information</b>


    <div id="question1A" class="question">
    <ol type="A" start="1"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Someone picks a name out of a hat known to contain the names of 5
women and 3 men, and tells you a man has been selected.
How much information have they given you about the selection?

<div id="control1A" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('1A'); return false">
          <img name="ctl1A" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer1A" class="answer" style="display:none"><font color="blue">
There are 8 names to start with and knowing the selection is a man
narrows the choices down to 3 names.  Using the formula from lecture
with N = 8 and M = 3, we've been given log<sub>2</sub>(8/3) bits
of information.

<p/>Alternatively, the probability of drawing a man's name is p<sub>man</sub> =
3/8, so the amount of information received is log<sub>2</sub>(1/p<sub>man</sub>) =
log<sub>2</sub>(1/(3/8)) = log<sub>2</sub>(8/3).

</font><div>
</li></ol></div>

    <div id="question1B" class="question">
    <ol type="A" start="2"><li>
    
You're given a standard deck of 52 playing cards that you start to
turn face up, card by card.  So far as you know, they're in completely
random order. How many new bits of information do you get when the
first card is flipped over?  The fifth card?  The last card?

<div id="control1B" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('1B'); return false">
          <img name="ctl1B" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer1B" class="answer" style="display:none"><font color="blue">
Before the first card was flipped over there are 52 choices for what
we'll see on the first flip.  Turning the first card over narrows the
choice down to a single card, so we've received log<sub>2</sub>(52/1)
bits of information.

<p/>After flipping over 4 cards, there are 48 choices for the next card,
so flipping over the fifth card gives us log<sub>2</sub>(48/1) bits of
information.

<p/>Finally if all but one card has been flipped over, we know ahead of
time what the final card has to be so we don't receive any information
from the last flip.  Using the formula, there is only 1 "choice" for the
card before the card is flipped and we have the same "choice" afterwards,
so, we receive log<sub>2</sub>(1/1) = 0 bits of information.

</font><div>
</li></ol></div>

    <div id="question1C" class="question">
    <ol type="A" start="3"><li>
    
X is an unknown N-bit binary number (N > 3).  You are told that the first
three bits of X are 011.  How many bits of information about X have
you been given?

<div id="control1C" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('1C'); return false">
          <img name="ctl1C" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer1C" class="answer" style="display:none"><font color="blue">
Since we were told about 3 bits of X it would make sense intuitively
that we've been given 3 bits of information!  Turning to the
formulas: there are 2<sup>N</sup> N-bit binary numbers and
2<sup>N-3</sup> N-bit binary numbers that begin with 011.  So
we've been given log<sub>2</sub>(2<sup>N</sup>/2<sup>N-3</sup>) = 
log<sub>2</sub>(2<sup>3</sup>) = 3 bits of information (whew!).

</font><div>
</li></ol></div>

    <div id="question1D" class="question">
    <ol type="A" start="4"><li>
    
<img src="star.gif" alt="Discussed in section"/>
X is an unknown 8-bit binary number.  You are given another
8-bit binary number, Y, and told that the Hamming distance
between X and Y is one.  How many bits of information about
X have you been given?

<div id="control1D" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('1D'); return false">
          <img name="ctl1D" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer1D" class="answer" style="display:none"><font color="blue">
Before we learn about Y, there are 2<sup>8</sup> = 256
choices for X.  If the Hamming distance between X and Y
is one that means that X and Y differ in only one of their
8 bits, i.e., for a given Y there are only eight possible
choices for X.  So we've been given 
log<sub>2</sub>(256/8) = 5 bits of information.

</font><div>
</li></ol></div>
</div>

    <div id="question2" class="question">
    <p/><hr/><p/><u>Problem 2.</u>
    
<b>Variable length encoding &amp; compression</b>


    <div id="question2A" class="question">
    <ol type="A" start="1"><li>
    
Huffman and other coding schemes tend to devote more bits
to the coding of
<ul>
(A) symbols carrying the most information<br/>
(B) symbols carrying the least information<br/>
(C) symbols that are likely to be repeated consecutively<br/>
(D) symbols containing redundant information
</ul>

<div id="control2A" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2A'); return false">
          <img name="ctl2A" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2A" class="answer" style="display:none"><font color="blue">
(A) symbols carrying the most information, i.e., the symbols that are
less likely to occur.  This makes sense: to keep messages as short as
possible, frequently occuring symbols should be encoded with fewer
bits and infrequent symbols with more bits.

</font><div>
</li></ol></div>

    <div id="question2B" class="question">
    <ol type="A" start="2"><li>
    
Consider the following two Huffman decoding tress for a
variable-length code involving 5 symbols: A, B, C, D and E.

<p/><center><img src="info01.gif"/></center>

<p/>Using Tree #1, decode the following encoded message:
"01000111101".

<div id="control2B" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2B'); return false">
          <img name="ctl2B" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2B" class="answer" style="display:none"><font color="blue">
To decode the message, start at the root of the tree
and consume digits as you traverse down the tree, stopping
when you reach a leaf node.  Repeat until all the digits
have been processed.  Processing the encoded message
from left-to-right:
<ul>
"0" => A<br/>
"100" => B<br/>
"0" => A<br/>
"111" => E<br/>
"101" => C<br/>
</ul>

</font><div>
</li></ol></div>

    <div id="question2C" class="question">
    <ol type="A" start="3"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Suppose we were encoding messages that the following probabilities
for each of the 5 symbols:
<ul>
p(A) = 0.5<br/>
p(B) = p(C) = p(D) = p(E) = 0.125
</ul>
Which of the two encodings above (Tree #1 or Tree #2) would yield
the shortest encoded messages averaged over many messages?

<div id="control2C" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2C'); return false">
          <img name="ctl2C" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2C" class="answer" style="display:none"><font color="blue">
Using Tree #1, the expected length of the encoding for one symbol is:
<ul>
1*p(A) + 3*p(B) + 3*p(C) + 3*p(D) + 3*p(E) = 2.0
</ul>
Using Tree #2, the expected length of the encoding for one symbol is:
<ul>
2*p(A) + 2*p(B) + 2*p(C) + 3*p(D) + 3*p(E) = 2.25
</ul>
So using the encoding represented by Tree #1 would yield shorter
messages on the average.

</font><div>
</li></ol></div>

    <div id="question2D" class="question">
    <ol type="A" start="4"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Using the probabilities for A, B, C, D and E given above,
construct a variable-length binary decoding tree using a simple
greedy algorithm as follows:

<p/><ol>

<li>Begin with the set S of symbols to be encoded as binary strings,
together with the probability P(x) for each symbol x.  The
probabilities sum to 1, and measure the frequencies with which each
symbol appears in the input stream.  In the example from lecture, the
initial set S contains the four symbols and associated probabilities
in the above table.</li>

<li>Repeat the following steps until there is only 1 symbol left in S:

<ol type="A">

<li>Choose the two members of S having lowest probabilities.  Choose
arbitrarily to resolve ties.  In the example above, D and E
might be the first nodes chosen.</li>

<li>Remove the selected symbols from S, and create a new node of the
decoding tree whose children (sub-nodes) are the symbols you've
removed.  Label the left branch with a "0", and the right branch with
a "1".  In the first iteration of the example above, the bottom-most
internal node (leading to D and E) would be created.</li>

<li>Add to S a new symbol (e.g., "DE" in our example) that
represents this new node.  Assign this new symbol a probability equal
to the sum of the probabilities of the two nodes it replaces.</li>

</ol>
</li>
</ol>

<div id="control2D" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2D'); return false">
          <img name="ctl2D" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2D" class="answer" style="display:none"><font color="blue">
<pre>
S = {A/0.5 B/0.125 C/0.125 D/0.125 E/0.125}
  arbitrarily choose D &amp; E
  encoding: "0" => D, "1" => E
S = {A/0.5 B/0.125 C/0.125 DE/0.25}
  choose B &amp; C
  encoding: "0" => B, "1" => C
S = {A/0.5 BC/0.25 DE/0.25}
  choose BC &amp; DE
  encoding: "00" => B, "01" => C, "10" => D, "11" => E
S = {A/0.5 BCDE/0.5}
  choose A &amp; BCDE
  encoding: "0" => A, "100" => B, "101" => C, "110" => D, "111" => E
S = {ABCDE/1.0}
</pre>

<p/>This is Tree #1 shown in the diagram above.  The choice of D &amp; E
as the first symbols to combine was arbitrary -- we could have
chosen any two symbols from B, C, D and E.  So there are many
equally plausible encodings that might emerge from this algorithm,
corresponding to interchanging B, C, D and E at the leaves of
the tree.

</font><div>
</li></ol></div>

    <div id="question2E" class="question">
    <ol type="A" start="5"><li>
    
Huffman coding is used to compactly encode the species of fish
tagged by a game warden.  If 50% of the fish are bass and the
rest are evenly distributed among 15 other species, how many
bits would be used to encode the species of a bass?

<div id="control2E" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2E'); return false">
          <img name="ctl2E" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2E" class="answer" style="display:none"><font color="blue">
1 bit, using the algorithm described above.

</font><div>
</li></ol></div>

    <div id="question2F" class="question">
    <ol type="A" start="6"><li>
    
Consider the sum of two six-sided dice.  Even when the dice are "fair"
the amount information conveyed by a single sum depends on what the
sum is since some sums are more likely than others, as shown in the
following figure:

<p/><center><img src="info02.gif"/></center>

<p/>What is the average number of bits of information provided by the
sum of 2 dice?  Suppose we want to transmit the sums resulting from
rolling the dice 1000 times.  How many bits should we expect that
transmission to take?

<div id="control2F" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2F'); return false">
          <img name="ctl2F" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2F" class="answer" style="display:none"><font color="blue">
Average number of bits = sum p<sub>i</sub>log<sub>2</sub>(1/p<sub>i</sub>)
for i = 2 through 12.  Using the probabilities given in the figure
above the average number of bits of information provided by the sum
of two dice is 3.2744.

<p/>So if we had the perfect encoding, the expected length of the
transmission would be 3274.4 bits.  If we encode each sum separately
we can't quite achieve this lower bound -- see the next question
for details.

</font><div>
</li></ol></div>

    <div id="question2G" class="question">
    <ol type="A" start="7"><li>
    
Suppose we want to transmit the sums resulting from rolling the dice
1000 times.  If we use 4 bits to encode each sum, we'll need 4000 bits
to transmit the result of 1000 rolls.  If we use a variable-length
binary code which uses shorter sequences to encode more likely sums
then the expected number of bits need to encode 1000 sums should be
less than 4000.  Construct a variable-length encoding for the sum of
two dice whose expected number of bits per sum is less than 3.5.
(Hint: It's possible to find an encoding for the sum of two dice with
an expected number of bits = 3.306.)

<div id="control2G" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2G'); return false">
          <img name="ctl2G" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2G" class="answer" style="display:none"><font color="blue">
Using the greedy algorithm given above, we arrive at the
following encoding which has 3.3056 as the expected number
of bits for each sum.

<p/><center><img src="info03.gif"/></center>

</font><div>
</li></ol></div>

    <div id="question2H" class="question">
    <ol type="A" start="8"><li>
    
Okay, so can we make an encoding for transmitting 1000 sums that
has an expected length smaller than 3306 bits?

<div id="control2H" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('2H'); return false">
          <img name="ctl2H" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer2H" class="answer" style="display:none"><font color="blue">
Yes, but we have to look at encoding more than one sum at
a time, e.g., by applying the construction algorithm to pairs
of sums, or ultimately to all 1000 sums at once.  Many of the
more sophisticated compression algorithms consider sequences of
symbols when constructing the appropriate encoding scheme.

</font><div>
</li></ol></div>
</div>

    <div id="question3" class="question">
    <p/><hr/><p/><u>Problem 3.</u>
    
<b>Variable-length encoding</b>

<p/>After spending the afternoon in the dentist's chair, Ben Bitdiddle
has invented a new language called DDS made up entirely of vowels (the
only sounds he could make with someone's hand in his mouth).  The DDS
alphabet consists of the five letters "A", "E", "I", "O", and "U"
which occur in messages with the following probabilities:

<p/><center><table border="1">
<tr><th>Letter</th><th>Probability of occurrence</th></tr>
<tr><td>A</td><td>p(A) = 0.15</td></tr>
<tr><td>E</td><td>p(E) = 0.4</td></tr>
<tr><td>I</td><td>p(I) = 0.15</td></tr>
<tr><td>O</td><td>p(O) = 0.15</td></tr>
<tr><td>U</td><td>p(U) = 0.15</td></tr>
</table></center>


    <div id="question3A" class="question">
    <ol type="A" start="1"><li>
    
<img src="star.gif" alt="Discussed in section"/>
If you are told that the first letter of a message is "A", give an
expression for the number of bits of information have you received.

<div id="control3A" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('3A'); return false">
          <img name="ctl3A" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer3A" class="answer" style="display:none"><font color="blue">
Using the formula given in lecture, the number of bits of information
is log<sub>2</sub>(1/p(A)) = log<sub>2</sub>(1/0.15)

</font><div>
</li></ol></div>

    <div id="question3B" class="question">
    <ol type="A" start="2"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Ben is trying to invent a fixed-length binary encoding for DDS that
permits detection and correction of single bit errors.  Briefly
describe the constraints on Ben's choice of encodings for each letter
that will ensure that single-bit error detection and correction is
possible.  (Hint: think about Hamming distance.)

<div id="control3B" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('3B'); return false">
          <img name="ctl3B" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer3B" class="answer" style="display:none"><font color="blue">
Each encoding must differ from other encodings in at least 3 bit
positions, i.e., encodings must have a Hamming distance &amp;gt;= 3.
This ensures that each received codeword (even those with single-bit
errors) can be associated with a particular source encoding.

</font><div>
</li></ol></div>

    <div id="question3C" class="question">
    <ol type="A" start="3"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Giving up on error detection and correction, Ben turns his attention
to transmitting DDS messages using as few bits as possible.  Assume
that each letter will be separately encoded for transmission.  Help
him out by creating a variable-length encoding that minimizes the
average number of bits transmitted for each letter of the message.

<div id="control3C" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('3C'); return false">
          <img name="ctl3C" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer3C" class="answer" style="display:none"><font color="blue">
Using the simple "greedy" algorithm described above:

<pre>
S = {A/0.15 E/0.4 I/0.15 O/0.15 U/0.15}
  arbitrarily choose O &amp; U
  encoding: "0" => O, "1" => U
S = {A/0.15 E/0.4 I/0.15 OU/0.3}
  choose A &amp; I
  encoding: "0" => A, "1" => I
S = {AI/0.3 E/0.4 OU/0.3}
  choose AI &amp; OU
  encoding: "00" => A, "01" => I, "10" => O, "11" => U
S = {AIOU/0.6 E/0.4}
  choose E &amp; AIOU
  encoding: "0" => E, "100" => A, "101" => I, "110" => O, "111" => U
S = {AEIOU/1.0}
</pre>

Note that the assignments of symbols to encodings "0" and "1"
were arbitrary and could have been swapped at each level.  So, for example,
swapping the encoding at the last step would have resulted in

<pre>
  encoding: "1" => E, "000" => A, "001" => I, "010" => O, "011" => U
</pre>

which achieves the same average bits/symbol as the previous encoding.

</font><div>
</li></ol></div>
</div>

    <div id="question4" class="question">
    <p/><hr/><p/><u>Problem 4.</u>
    
<b>Modular arithmetic and 2's complement representation</b>

<p/>Most computers choose a particular word length (measured in bits)
for representing integers and provide hardware that performs various
arithmetic operations on word-size operands.  The current generation
of processors have word lengths of 32 bits; restricting the size of
the operands and the result to a single word means that the arithmetic
operations are actually performing arithmetic modulo 2<sup>32</sup>.

<p/>Almost all computers use a 2's complement representation for
integers since the 2's complement addition operation is the same for
both positive and negative numbers.  In 2's complement notation, one
negates a number by forming the 1's complement (i.e., for each bit,
changing a 0 to 1 and vice versa) representation of the number and
then adding 1.  By convention, we write 2's complement integers with
the most-significant bit (MSB) on the left and the least-significant
bit (LSB) on the right.  Also by convention, if the MSB is 1, the
number is negative; otherwise it's non-negative.


    <div id="question4A" class="question">
    <ol type="A" start="1"><li>
    
How many different values can be encoded in a 32-bit word?

<div id="control4A" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('4A'); return false">
          <img name="ctl4A" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer4A" class="answer" style="display:none"><font color="blue">
Each bit can be either "0" or "1", so there are 2<sup>32</sup>
possible values which can be encoded in a 32-bit word.

</font><div>
</li></ol></div>

    <div id="question4B" class="question">
    <ol type="A" start="2"><li>
    
Please use a 32-bit 2's complement representation to answer the
following questions.  What are the representations for
<ul>
zero<br/>
the most positive integer that can be represented<br/>
the most negative integer that can be represented
</ul>
What are the decimal values for the most positive and most negative integers?

<div id="control4B" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('4B'); return false">
          <img name="ctl4B" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer4B" class="answer" style="display:none"><font color="blue">
zero = 0000 0000 0000 0000 0000 0000 0000 0000<br/>
most positive integer = 0111 1111 1111 1111 1111 1111 1111 1111 = 2<sup>31</sup>-1<br/>
most negative integer = 1000 0000 0000 0000 0000 0000 0000 0000 = -2<sup>31</sup><br/>

</font><div>
</li></ol></div>

    <div id="question4C" class="question">
    <ol type="A" start="3"><li>
    
Since writing a string of 32 bits gets tedious, it's often convenient
to use hexadecimal notation where a single digit in the range 0-9 or
A-F is used to represent groups of 4 bits using the following
encoding:

<pre>
	hex bits        hex bits        hex bits        hex bits
	 0  0000         4  0100         8  1000         C  1100
	 1  0001         5  0101         9  1001         D  1101
	 2  0010         6  0110         A  1010         E  1110
	 3  0011         7  0111         B  1011         F  1111
</pre>

Give the 8-digit hexadecimal equivalent of the following decimal and
binary numbers: 37<sub>10</sub>, -32768<sub>10</sub>, 11011110101011011011111011101111<sub>2</sub>.
	
<div id="control4C" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('4C'); return false">
          <img name="ctl4C" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer4C" class="answer" style="display:none"><font color="blue">
37 = 00000025<sub>16</sub><br/>
-32768 = FFFF8000<sub>16</sub><br/>
1101 1110 1010 1101 1011 1110 1110 1111<sub>2</sub> = DEADBEEF<sub>16</sub>

</font><div>
</li></ol></div>

    <div id="question4D" class="question">
    <ol type="A" start="4"><li>
    
<img src="star.gif" alt="Discussed in section"/>
Calculate the following using 6-bit 2's complement arithmetic (which
is just a fancy way of saying to do ordinary addition in base 2
keeping only 6 bits of your answer).  Show your work using binary
(base 2) notation.  Remember that subtraction can be performed by
negating the second operand and then adding it to the first operand.
<pre>
	13 + 10  
	15 - 18
	27 - 6
	-6 - 15
	21 + (-21)
	31 + 12
</pre>
Explain what happened in the last addition and in what sense your
answer is "right".
	
<div id="control4D" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('4D'); return false">
          <img name="ctl4D" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer4D" class="answer" style="display:none"><font color="blue">
<pre>
  13 = 001101      15 = 001111      27 = 011011
+ 10 = 001010     -18 = 101110     - 6 = 111010
  ===========      ===========      ===========
  23 = 010111      -3 = 111101      21 = 010101

  -6 = 111010      21 = 010101      31 = 011111
 -15 = 110001     -21 = 101011     +12 = 001100
  ===========     ============      ===========
 -21 = 101011       0 = 000000     -21 = 101011 (!)
</pre>

<p/>In the last addition, 31 + 12 = 43 exceeds the maximum
representable positive integer in 6-bit two's complement
arithmetic (max int = 2<sup>5</sup>-1 = 31).  The addition
caused the most significant bit to become 1, resulting in
an "overflow" where the sign of the result differs from the
signs of the operands.

</font><div>
</li></ol></div>

    <div id="question4E" class="question">
    <ol type="A" start="5"><li>
    
At first blush "Complement and add 1" doesn't seem to an obvious way
to negate a two's complement number.  By manipulating the expression
A+(-A)=0, show that "complement and add 1" does produce the correct
representation for the negative of a two's complement number.
Hint: express 0 as (-1+1) and rearrange terms to get -A on one
side and XXX+1 on the other and then think about how the expression
XXX is related to A using only logical operations (AND, OR, NOT).

<div id="control4E" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('4E'); return false">
          <img name="ctl4E" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer4E" class="answer" style="display:none"><font color="blue">
Start by expressing zero as (-1 + 1):
<ul>
A + (-A) = -1 + 1
</ul>
Rearranging terms we get:
<ul>
(-A) = (-1 - A) + 1
</ul>
The two's complement representation for -1 is all ones, so looking
at (-1 - A) bit-by-bit we see:
<pre>
   1   ...  1   1
-  A<sub>N-1</sub> ...  A<sub>1</sub>  A<sub>0</sub>
  ===============
  ~A<sub>N-1</sub> ... ~A<sub>1</sub> ~A<sub>0</sub>
</pre>
where "~" is the bit-wise complement operator.
We've used regular subtraction rules (1 - 0 = 1, 1 - 1 = 0) and noticed
that in each bit position 1 - A<sub>i</sub> = ~A<sub>i</sub>.  So, finally:
<ul>
(-A) = ~A + 1
</ul>

</font><div>
</li></ol></div>
</div>

    <div id="question5" class="question">
    <p/><hr/><p/><u>Problem 5.</u>
    
<b>Error detection and correction</b>


    <div id="question5A" class="question">
    <ol type="A" start="1"><li>
    
To protect stored or transmitted information one can add check bits to
the data to facilitate error detection and correction.  One scheme for
detecting single-bit errors is to add a parity bit:

<p/><ul>
b<sub>0</sub> b<sub>1</sub> b<sub>2</sub>  b<sub>N-1</sub> p
</ul>

<p/>When using even parity, p is chosen so that the number of "1" bits
in the protected field (including the p bit itself) is even; when
using odd parity, p is chosen so that the number of "1" bits is odd.
In the remainder of this problem assume that even parity is used.

<p/>To check parity-protected information to see if an error has occurred,
simply compute the parity of information (including the parity bit)
and see if the result is correct.  For example, if even parity was
used to compute the parity bit, you would check if the number of "1"
bits was even.
 
<p/>If an error changes one of the bits in the parity-protected
information (including the parity bit itself), the parity will be
wrong, i.e., the number of "1" bits will be odd instead of even.
Which of the following parity-protected bit strings has a detectable
error assuming even parity?

<p/><ul><tt>
(1) 11101101111011011<br/>
(2) 11011110101011110<br/>
(3) 10111110111011110<br/>
(4) 00000000000000000
</tt></ul>

<div id="control5A" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('5A'); return false">
          <img name="ctl5A" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer5A" class="answer" style="display:none"><font color="blue">
Strings 1 and 3 have detectable errors.  Note that parity allows
one to detect single-bit errors (actually any odd number of errors)
but doesn't defend against an even number of bit errors.

</font><div>
</li></ol></div>

    <div id="question5B" class="question">
    <ol type="A" start="2"><li>
    
Detecting errors is useful, but it would also be nice to correct them!
To build an error correcting code (ECC) we'll use additional check
bits to help pinpoint where the error occurred.  There are many such
codes; a particularly simple one for detecting and correcting
single-bit errors arranges the data into rows and columns and then
adds (even) parity bits for each row and column.  The following
arrangement protects nine data bits:

<pre>
b0,0	b0,1	b0,2	prow0
b1,0	b1,1	b1,2	prow1
b2,0	b2,1	b2,2	prow2
pcol0	pcol1	pcol2
</pre>

A single-bit error in one of the data bits (b<sub>I,J</sub>) will generate two
parity errors, one in row I and one in column J.  A single-bit error
in one of the parity bits will generate just a single parity error for
the corresponding row or column.  So after computing the parity of
each row and column, if both a row and a column parity error are
detected, inverting the listed value for the appropriate data bit will
produce the corrected data.  If only a single parity error is
detected, the data is correct (the error was one of the parity bits).

<p/>Give the correct data for each of the following data blocks
protected with the row/column ECC shown above.

<pre>
(1)  1011    (2) 1100    (3) 000    (4) 0111
     0110        0000        111        1001
     0011        0101        10         0110
     011         100                    100
</pre>

<div id="control5B" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('5B'); return false">
          <img name="ctl5B" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer5B" class="answer" style="display:none"><font color="blue">
<pre>
(1)  <font color="red">0</font>011    (2) 1100    (3) 000    (4) 011<font color="red">0</font>
     0110        0000        1<font color="red">0</font>1        1001
     0011        0101        10         0110
     011         100                    100
</pre>
(1) and (3) had single bit errors, (2) had no detectable errors, and (4)
had an error in a parity bit.  The red digits represent corrected values.

</font><div>
</li></ol></div>

    <div id="question5C" class="question">
    <ol type="A" start="3"><li>
    
The row/column ECC can also detect many double-bit errors (i.e., two
of the data or check bits have been changed).  Characterize the sort
of double-bit errors the code does not detect.

<div id="control5C" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('5C'); return false">
          <img name="ctl5C" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer5C" class="answer" style="display:none"><font color="blue">
If parity bits detect an error for exactly one column and exactly one
row, this will be interpreted as a single bit error in the
corresponding data position. This can happen with two parity bit
errors, one in each of the row and column check bits.
The fact that two errors occurred is not
detected; worse, the corresponding data position is changed
from the correct value to the incorrect value.

</font><div>
</li></ol></div>

    <div id="question5D" class="question">
    <ol type="A" start="4"><li>
    
In the days of punch cards, decimal digits were represented with a special
encoding called <i>2-out-of-5 code</i>.  As the name implies two out of
five positions were filled with 1's as shown in the table below:

<p/><center><table border="1" cellpadding="2">
<tr><th>Code</th><th>Decimal</th></tr>
<tr><td>11000</td><td>1</td></tr>
<tr><td>10100</td><td>2</td></tr>
<tr><td>01100</td><td>3</td></tr>
<tr><td>10010</td><td>4</td></tr>
<tr><td>01010</td><td>5</td></tr>
<tr><td>00110</td><td>6</td></tr>
<tr><td>10001</td><td>7</td></tr>
<tr><td>01001</td><td>8</td></tr>
<tr><td>00101</td><td>9</td></tr>
<tr><td>00011</td><td>0</td></tr>
</table></center>

<p/>What is the smallest Hamming distance between any two encodings
in <i>2-out-of-5 code</i>?

<div id="control5D" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('5D'); return false">
          <img name="ctl5D" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer5D" class="answer" style="display:none"><font color="blue">
The Hamming distance between any two encodings is the number of bit
positions in which the encodings differs.  With this code, the
smallest Hamming distance is 2.

</font><div>
</li></ol></div>

    <div id="question5E" class="question">
    <ol type="A" start="5"><li>
    
Characterize the types of errors (eg, 1- and 2-bit errors) that can
be reliably detected in a <i>2-out-of-5 code</i>?

<div id="control5E" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('5E'); return false">
          <img name="ctl5E" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer5E" class="answer" style="display:none"><font color="blue">
Codes with a Hamming distance of 2 can detect 1-bit errors.  The
2-out-of-5 code also detects 3-bit errors, but not 2-bit errors.
Normally when we say a code detects n-bit errors we imply that
it detects m-bit errors for m &lt; n.  Following this convention,
we would say that the 2-out-of-5 code detects 1-bit errors.

</font><div>
</li></ol></div>

    <div id="question5F" class="question">
    <ol type="A" start="6"><li>
    
We know that <i>even parity</i> is another scheme for detecting
errors.  If we change from a 2-out-of-5 code to a 5-bit code
that includes an even parity bit, how many <i>additional</i>
data encodings become available?

<div id="control5F" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('5F'); return false">
          <img name="ctl5F" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer5F" class="answer" style="display:none"><font color="blue">
There are 16 possible values for the 4 data bits in the 5-bit
parity encoding, six more than the 10 possible values in the
2-out-of-5 code.

</font><div>
</li></ol></div>
</div>

    <div id="question6" class="question">
    <p/><hr/><p/><u>Problem 6.</u>
    
<b>Hamming single-error-correcting-code</b>

<p/>The Hamming single-error-correcting code requires approximately
log2(N) check bits to correct single-bit errors.  Start by renumbering
the data bits with indices that aren't powers of two:

<ul>
Indices for 16 data bits = 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21
</ul>

<p/>The idea is to compute the check bits choosing subsets of the data
in such a way that a single-bit error will produce a set of parity
errors that uniquely indicate the index of the faulty bit:

<ul>
p0 = even parity for data bits 3, 5, 7, 9, 11, 13, 15, 17, 19, 21<br/>
p1 = even parity for data bits 3, 6, 7, 10, 11, 14, 15, 18, 19<br/>
p2 = even parity for data bits 5, 6, 7, 12, 13, 14, 15, 20, 21<br/>
p3 = even parity for data bits 9, 10, 11, 12, 13, 14, 15<br/>
p4 = even parity for data bits 17, 18, 19, 20, 21<br/>
</ul>

<p/>Note that each data bit appears in at least two of the parity
calculations, so a single-bit error in a data bit will produce at
least two parity errors.  When checking a protected data field, if the
number of parity errors is zero or one, the data bits are okay
(exactly one parity error indicates that one of the parity bits was
corrupted).  If two or more parity errors are detected then the errors
identify exactly which bit was corrupted.


    <div id="question6A" class="question">
    <ol type="A" start="1"><li>
    
What is the relationship between the index of a particular data bit
and the check subsets in which it appears?  Hint: consider the binary
representation of the index.

<div id="control6A" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('6A'); return false">
          <img name="ctl6A" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer6A" class="answer" style="display:none"><font color="blue">
Digit <i>i</i> in the binary expansion of a data bit index indicates
whether the index should be included in the calculation of p<i>i</i>.
For example, the first data bit (which has index 3 = 00011)
would be used in the parity calculation for parity bits p0
and p1.  Likewise, the sixth data bit (which has index 10 = 01010)
would be used in the parity calculation for parity bits p1 and p3.
Since no data bit is assigned an index which is a power
of two, we guarantee that each data bit is used in the calculation
of at least two different parity bits.

</font><div>
</li></ol></div>

    <div id="question6B" class="question">
    <ol type="A" start="2"><li>
    
If the parity calculations involving p0, p2 and p3 fail, assuming a
single-bit error what is the index of the faulty data bit? 

<div id="control6B" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('6B'); return false">
          <img name="ctl6B" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer6B" class="answer" style="display:none"><font color="blue">
We need to find the data index that appears in the calculation
p0, p2 and p3 but <i>not</i> in the calculations for p1 and p4.  
Indicies 13 and 15 appear in p0, p2 and p3, but index 15 appears
in the calculation for p1.  So the index of the data bit that
failed is 13.

<p/>We can construct the index of the failing data bit directly from
the parity calculations using e<i>i</i> = 1 if the p<i>i</i> failed
and e<i>i</i> = 0 if it didn't.  So if p0, p2 and p3 failed, and the
others didn't, the index is e4e3e2e1e0 = 01101 = 13<sub>10</sub>.

</font><div>
</li></ol></div>

    <div id="question6C" class="question">
    <ol type="A" start="3"><li>
    
The Hamming SECC doesn't detect all double-bit errors.  Characterize
the types of double-bit errors that will not be detected.  Suggest a
simple addition to the Hamming SECC that allows detection of all
double-bit errors.

<div id="control6C" class="control" style="padding-top: 8px; padding-bottom: 8px">
        <a href="#" onClick="toggle('6C'); return false">
          <img name="ctl6C" class="hideshow" src="show.gif" border="0"/>
        </a></div> <div id="answer6C" class="answer" style="display:none"><font color="blue">
If errors occur in two separate parity bits, this will be
misinterpreted as a single data bit error.  Also when certain
pairs of data bits have errors, the double-bit error masquerades
as a single-bit error in another, unrelated bit (e.g., suppose
bits with indicies 19 and 21 both have errors).

<p/>We can detect these situations by adding an additional parity
bit, p5, which is the parity of all other parity and data bits.
If a single data bit failed, this bit would indicate and error.
But if exactly two bits have failed, p5 would indicate no
error, but p0, p1, ..., p4 would indicate the presence of some
error (although the indication might point at the wrong data bit).
So, if by looking at p0, p1, ..., p4 it seems as though an error
occurred, we should check p5 to make sure that only one error
occurred.  If p5 does not indicate an error, then a double-bit
error occurred.




</font><div>
</li></ol></div>
</div>
</body></html>
